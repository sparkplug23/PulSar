
// #ifdef USE_DEVFEATURE_UART_TEST
// /* 
// UART Interrupt Example
// */
// #ifdef CORE_DEBUG_LEVEL
// #undef CORE_DEBUG_LEVEL
// #endif

/**
 * Returns: Bytes read from buffer and thus freed
 * Arg:     Buffer to write into and its size, or simply, how much to read at a time
 * Possible change: Read until length, or stop on a special character (with possible relative index also ie "a,5x" detect comma, plus 2)
 * For me, use new line
 * */
uint16_t mSerialUART::GetReceiveBuffer2(char* output_buf, uint16_t output_len, char optional_read_until_char, bool flag_clear_buffer_after_read)
{
  uint16_t bytes_to_read =0;
// xRingbufferPrintInfo(settings.uart2.ringbuffer_handle);
      // //Receive an item from no-split ring buffer
      size_t item_size;
      // Wait at most 1ms to read from buffer
      char*  item = (char *)xRingbufferReceive(pCONT_uart->settings.uart2.ringbuffer_handle, &item_size, pdMS_TO_TICKS(100));

      //Check received item
      if (item != NULL) {
        // AddLog(LOG_LEVEL_TEST, PSTR("UART2:>%d %d sizeB=%d"),item_size,millis(),xRingbufferGetCurFreeSize(pCONT_uart->settings.uart2.ringbuffer_handle));
        //Print item
        // for(int i = 0; i < item_size; i++) {
        //   Serial.printf("%c", item[i]);          
        // }

        bytes_to_read = item_size > output_len ? output_len : item_size;

        // AddLog(LOG_LEVEL_TEST, PSTR("bytes_to_read=%d, item_size=%d, output_len=%d"),bytes_to_read,item_size,output_len);
        // Read from buffer
        // snprintf(output_buf, output_len)
        memcpy(output_buf,item,bytes_to_read*sizeof(char));

        AddLog(LOG_LEVEL_TEST, PSTR("output_buf=%s"),output_buf);


// if(flag_clear_buffer_after_read)
// {
        //Return Item
        vRingbufferReturnItem(pCONT_uart->settings.uart2.ringbuffer_handle, (void *)item); // Free memory
        // AddLog(LOG_LEVEL_TEST, PSTR("sizeA=%d"),xRingbufferGetCurFreeSize(pCONT_uart->settings.uart2.ringbuffer_handle));
// }
      } 
      // else {
      //   //Failed to receive item EMPTY
      //   // AddLog(LOG_LEVEL_TEST, PSTR("Failed to receive item"));
      // }

  return bytes_to_read;

}
/**
 * Returns: Bytes read from buffer and thus freed
 * Arg:     Buffer to write into and its size, or simply, how much to read at a time
 * Possible change: Read until length, or stop on a special character (with possible relative index also ie "a,5x" detect comma, plus 2)
 * For me, use new line
 * */
uint16_t mSerialUART::GetReceiveBufferPartial2(char* output_buf, uint16_t output_len, char optional_read_until_char, bool flag_clear_buffer_after_read)
{
  uint16_t bytes_to_read =0;
// xRingbufferPrintInfo(settings.uart2.ringbuffer_handle);
      // //Receive an item from no-split ring buffer
      size_t item_size;
      // Wait at most 1ms to read from buffer
      char*  item = (char *)xRingbufferReceiveUpTo(pCONT_uart->settings.uart2.ringbuffer_handle, &item_size, pdMS_TO_TICKS(100), output_len);

      //Check received item
      if (item != NULL) {
        // AddLog(LOG_LEVEL_TEST, PSTR("UART2:>%d %d sizeB=%d"),item_size,millis(),xRingbufferGetCurFreeSize(pCONT_uart->settings.uart2.ringbuffer_handle));
        //Print item
        // for(int i = 0; i < item_size; i++) {
        //   Serial.printf("%c", item[i]);          
        // }

        bytes_to_read = item_size > output_len ? output_len : item_size;

        // AddLog(LOG_LEVEL_TEST, PSTR("bytes_to_read=%d, item_size=%d, output_len=%d"),bytes_to_read,item_size,output_len);
        // Read from buffer
        // snprintf(output_buf, output_len)
        memcpy(output_buf,item,bytes_to_read*sizeof(char));

        AddLog(LOG_LEVEL_TEST, PSTR("output_buf=%s"),output_buf);


// if(flag_clear_buffer_after_read)
// {
        //Return Item
        vRingbufferReturnItem(pCONT_uart->settings.uart2.ringbuffer_handle, (void *)item); // Free memory
        // AddLog(LOG_LEVEL_TEST, PSTR("sizeA=%d"),xRingbufferGetCurFreeSize(pCONT_uart->settings.uart2.ringbuffer_handle));
// }
      } 
      // else {
      //   //Failed to receive item EMPTY
      //   // AddLog(LOG_LEVEL_TEST, PSTR("Failed to receive item"));
      // }

  return bytes_to_read;

}



/**
 * Returns: Bytes read from buffer and thus freed
 * Arg:     Buffer to write into and its size, or simply, how much to read at a time
 * Possible change: Read until length, or stop on a special character (with possible relative index also ie "a,5x" detect comma, plus 2)
 * For me, use new line
 * */
uint16_t mSerialUART::GetReceiveBuffer1(char* output_buf, uint16_t output_len, char optional_read_until_char, bool flag_clear_buffer_after_read)
{
  uint16_t bytes_to_read =0;
// xRingbufferPrintInfo(settings.uart2.ringbuffer_handle);
      // //Receive an item from no-split ring buffer
      size_t item_size;
      // Wait at most 1ms to read from buffer
      char*  item = (char *)xRingbufferReceive(pCONT_uart->settings.uart1.ringbuffer_handle, &item_size, pdMS_TO_TICKS(100));

      //Check received item
      if (item != NULL) {
        // AddLog(LOG_LEVEL_TEST, PSTR("UART2:>%d %d sizeB=%d"),item_size,millis(),xRingbufferGetCurFreeSize(pCONT_uart->settings.uart2.ringbuffer_handle));
        //Print item
        // for(int i = 0; i < item_size; i++) {
        //   Serial.printf("%c", item[i]);          
        // }

        bytes_to_read = item_size > output_len ? output_len : item_size;

        // AddLog(LOG_LEVEL_TEST, PSTR("bytes_to_read=%d, item_size=%d, output_len=%d"),bytes_to_read,item_size,output_len);
        // Read from buffer
        // snprintf(output_buf, output_len)
        memcpy(output_buf,item,bytes_to_read*sizeof(char));

        AddLog(LOG_LEVEL_TEST, PSTR("output_buf=%s"),output_buf);


// if(flag_clear_buffer_after_read)
// {
        //Return Item
        vRingbufferReturnItem(pCONT_uart->settings.uart1.ringbuffer_handle, (void *)item); // Free memory
        // AddLog(LOG_LEVEL_TEST, PSTR("sizeA=%d"),xRingbufferGetCurFreeSize(pCONT_uart->settings.uart2.ringbuffer_handle));
// }
      } 
      // else {
      //   //Failed to receive item EMPTY
      //   // AddLog(LOG_LEVEL_TEST, PSTR("Failed to receive item"));
      // }

  return bytes_to_read;

}



// #define CORE_DEBUG_LEVEL 3
// #define LOG_LOCAL_LEVEL ESP_LOG_DEBUG

// #ifdef USE_DEVFEATURE_RINGBUFFERS
// #include "freertos/ringbuf.h"
// // static char tx_item[] = "test_item";
// #include <stdio.h>
// #include <string.h>
// #include "freertos/FreeRTOS.h"
// #include "freertos/task.h"
// #include "freertos/queue.h"
// #include "driver/uart.h"
// #include "esp_log.h"
// #include "driver/gpio.h"
// #include "sdkconfig.h"
// #include "esp_intr_alloc.h"


// #define BUF_HANDLE_LENGTH 10000

// #define BLINK_GPIO GPIO_NUM_2

// // static const char *TAG = "uart_events";

// // Setup UART buffered IO with event queue
// const int uart_buffer_size = (1024 * 2);
// QueueHandle_t uart2_event_queue_handle;


// static QueueHandle_t buffer_queue;
// char buffer_test[100];

//     //Create ring buffer
//     RingbufHandle_t buf_handle;
// #endif
// // #define RINGBUFFER_HANDLE_2_LENGTH 10000
// // struct settings.uart2{
// //   RingbufHandle_t ringbuffer_handle;
// //   uint8_t initialised = false;
// // }settings.uart2;

// /**
//  * This example shows how to use the UART driver to handle UART interrupt.
//  *
//  * - Port: UART0
//  * - Receive (Rx) buffer: on
//  * - Transmit (Tx) buffer: off
//  * - Flow control: off
//  * - Event queue: on
//  * - Pin assignment: TxD (default), RxD (default)
//  */

//   void   init_UART0();
//   void   init_UART1();
//   void   init_UART2();

// #define EX_UART_NUM UART_NUM_0
// #define PATTERN_CHR_NUM    (3)         /*!< Set the number of consecutive and identical characters received by receiver which defines a UART pattern*/

// #define BUF_SIZE (1024)
// #define RD_BUF_SIZE (BUF_SIZE)
// static QueueHandle_t uart0_queue;
// static QueueHandle_t queue_rx_u2;

// // Both definition are same and valid
// //static uart_isr_handle_t *handle_console;
// static intr_handle_t handle_console;
// static intr_handle_t handle_console_u0;


// uint32_t ticktest = millis();
// uint32_t tick_fill = millis();
// uint32_t tick_read = millis();
// uint16_t number = 0;
// uint16_t  freeSize = 0;


// // Receive buffer to collect incoming data
// uint8_t rxbuf[256];
// // Register to collect data length
// uint16_t urxlen;

// #define NOTASK 0

// //https://www.reddit.com/r/esp32/comments/8k6ruk/uart_interrupt_not_working/
// static uart_isr_handle_t *handle_console4;

// uint8_t argISR;

// static const char *TAG4 = "uart_events";

// /**
//  * This example shows how to use the UART driver to handle special UART events.
//  *
//  * It also reads data from UART0 directly, and echoes it to console.
//  *
//  * - Port: UART0
//  * - Receive (Rx) buffer: on
//  * - Transmit (Tx) buffer: off
//  * - Flow control: off
//  * - Event queue: on
//  * - Pin assignment: TxD (default), RxD (default)
//  */
//   struct AMessage
//    {
//   	char ucMessageID;
//   	char ucData[ 20 ];
//    } xMessage;
 
//    QueueHandle_t xQueue;

// // This will run forever! I dont want this, as a thread, use a flag in the main loop instead
// static void uart_event_task(void *pvParameters)
// {
//     uart_event_t event;
//     size_t buffered_size;
//     uint8_t* dtmp = (uint8_t*) malloc(RD_BUF_SIZE);

     
//     // Task to create a queue and post a value.
//   //  void vATask( void *pvParameters )
//   //  {
// //    struct AMessage *pxMessage;
 
// //   	// Create a queue capable of containing 10 pointers to AMessage structures.
// //   	// These should be passed by pointer as they contain a lot of data.
// //   	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
// //  	  if( xQueue == 0 )
// //   	{
// //   		// Failed to create the queue.
// //   	}

// // //  uart0_queue


// //   	// ...
 
// //   	// Send a pointer to a struct AMessage object.  Don't block if the
// //   	// queue is already full.
// //   	pxMessage = & xMessage;
// //   	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
 
// //   	// ... Rest of task code.
// //   //  }
 
// //   //  // Task to receive from the queue.
// //   //  void vADifferentTask( void *pvParameters )
// //   //  {
// //    struct AMessage *pxRxedMessage;
 
// //   // 	if( xQueue != 0 )
// //   // 	{
// //   // 		// Receive a message on the created queue.  Block for 10 ticks if a
// //   // 		// message is not immediately available.
// //   		if( xQueueReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
// //   		{
// //   			// pcRxedMessage now points to the struct AMessage variable posted
// //   			// by vATask.
// //   		}
//   // 	}

//   uint32_t time1 = millis();
  
  
//       Serial.println("start");
  
//     // for(;;) {

//       // yield();
//       // ESP_LOGI(TAG, "uart[%d] event:", UART_NUM_2);

 
//   	// Create a queue capable of containing 10 pointers to AMessage structures.
//   	// These should be passed by pointer as they contain a lot of data.
//   	// uart0_queue = xQueueCreate( 10, sizeof( struct AMessage * ) );
//   	// if( uart0_queue == 0 )
//   	// {
//   	// 	// Failed to create the queue.
//   	// }
  
//   if(abs(millis()-time1)>1000){
//     time1 = millis();
//       Serial.println("for");
//   }
  

// /*

//         //Waiting for UART event.
//         if(xQueueReceive(uart0_queue, (void * )&event, (portTickType)portMAX_DELAY)) {
          
//       Serial.println("art[%d] even1");

//             bzero(dtmp, RD_BUF_SIZE);
//             ESP_LOGI(TAG, "uart[%d] event:", UART_NUM_2);
//             switch(event.type) {
//                 //Event of UART receving data
//                 // *We'd better handler data event fast, there would be much more data events than
//                 // other types of events. If we take too much time on data event, the queue might
//                 // be full.*
//                 case UART_DATA:
//                     ESP_LOGI(TAG, "[UART DATA]: %d", event.size);
//                     uart_read_bytes(UART_NUM_2, dtmp, event.size, portMAX_DELAY);
//                     ESP_LOGI(TAG, "[DATA EVT]:");
//                     uart_write_bytes(UART_NUM_2, (const char*) dtmp, event.size);
//                     break;
//                 //Event of HW FIFO overflow detected
//                 // case UART_FIFO_OVF:
//                 //     ESP_LOGI(TAG, "hw fifo overflow");
//                 //     // If fifo overflow happened, you should consider adding flow control for your application.
//                 //     // The ISR has already reset the rx FIFO,
//                 //     // As an example, we directly flush the rx buffer here in order to read more data.
//                 //     uart_flush_input(UART_NUM_2);
//                 //     xQueueReset(uart0_queue);
//                 //     break;
//                 // //Event of UART ring buffer full
//                 // case UART_BUFFER_FULL:
//                 //     ESP_LOGI(TAG, "ring buffer full");
//                 //     // If buffer full happened, you should consider encreasing your buffer size
//                 //     // As an example, we directly flush the rx buffer here in order to read more data.
//                 //     uart_flush_input(UART_NUM_2);
//                 //     xQueueReset(uart0_queue);
//                 //     break;
//                 // //Event of UART RX break detected
//                 // case UART_BREAK:
//                 //     ESP_LOGI(TAG, "uart rx break");
//                 //     break;
//                 // //Event of UART parity check error
//                 // case UART_PARITY_ERR:
//                 //     ESP_LOGI(TAG, "uart parity error");
//                 //     break;
//                 // //Event of UART frame error
//                 // case UART_FRAME_ERR:
//                 //     ESP_LOGI(TAG, "uart frame error");
//                 //     break;
//                 // //UART_PATTERN_DET
//                 // case UART_PATTERN_DET:{
//                 //     uart_get_buffered_data_len(UART_NUM_2, &buffered_size);
//                 //     int pos = uart_pattern_pop_pos(UART_NUM_2);
//                 //     ESP_LOGI(TAG, "[UART PATTERN DETECTED] pos: %d, buffered size: %d", pos, buffered_size);
//                 //     if (pos == -1) {
//                 //         // There used to be a UART_PATTERN_DET event, but the pattern position queue is full so that it can not
//                 //         // record the position. We should set a larger queue size.
//                 //         // As an example, we directly flush the rx buffer here.
//                 //         uart_flush_input(UART_NUM_2);
//                 //     } else {
//                 //         uart_read_bytes(UART_NUM_2, dtmp, pos, 100 / portTICK_PERIOD_MS);
//                 //         uint8_t pat[PATTERN_CHR_NUM + 1];
//                 //         memset(pat, 0, sizeof(pat));
//                 //         uart_read_bytes(UART_NUM_2, pat, PATTERN_CHR_NUM, 100 / portTICK_PERIOD_MS);
//                 //         ESP_LOGI(TAG, "read data: %s", dtmp);
//                 //         ESP_LOGI(TAG, "read pat : %s", pat);
//                 //     }
//                 // }
//                 //     break;
//                 //Others
//                 default:
//                     ESP_LOGI(TAG, "uart event type: %d", event.type);
//                     break;
//             }
//         } //queue
//         // yield(); //feed WDT?
        
//     */


//     // } //end for 



//     free(dtmp);
//     dtmp = NULL;
//     vTaskDelete(NULL);
// }




// void blink_task(void *pvParameter)
// {
//     gpio_pad_select_gpio(BLINK_GPIO);
    
//     /* Set the GPIO as a push/pull output */
//     gpio_set_direction(BLINK_GPIO, GPIO_MODE_OUTPUT);
    
//     while(1) {
//         /* Blink off (output low) */
//         gpio_set_level(BLINK_GPIO, 0);
//         vTaskDelay(1000 / portTICK_PERIOD_MS);
//         /* Blink on (output high) */
//         gpio_set_level(BLINK_GPIO, 1);
//         vTaskDelay(1000 / portTICK_PERIOD_MS);
//   //        uart_write_bytes(
//   // //  EX_UART_NUM, 
//   //  UART_NUM_0,
//   //  (const char*) "blink_task", 7);

//     }
// }
// // /*
// //  * Define UART interrupt subroutine to ackowledge interrupt
// //  */
// // static void IRAM_ATTR uart_intr_handle(void *arg)
// // {
// //   uint16_t rx_fifo_len, status;
// //   uint16_t i;
  
// //     gpio_pad_select_gpio(BLINK_GPIO);
    
// //     /* Set the GPIO as a push/pull output */
// //     gpio_set_direction(BLINK_GPIO, GPIO_MODE_OUTPUT);


// //   status = UART2.int_st.val; // read UART interrupt Status
// //   rx_fifo_len = UART2.status.rxfifo_cnt; // read number of bytes in UART buffer
  
// //   while(rx_fifo_len){
// //    rxbuf[i++] = UART2.fifo.rw_byte; // read all bytes
// //    rx_fifo_len--;
// //         gpio_set_level(BLINK_GPIO, !gpio_get_level(BLINK_GPIO));
// //  }
    
// //         // /* Blink off (output low) */
// //         // gpio_set_level(BLINK_GPIO, !gpio_get_level(BLINK_GPIO));
// //         /* Blink on (output high) */
// //         // gpio_set_level(BLINK_GPIO, 1);
  
// // //  // after reading bytes from buffer clear UART interrupt status
// //  uart_clear_intr_status(EX_UART_NUM, UART_RXFIFO_FULL_INT_CLR|UART_RXFIFO_TOUT_INT_CLR);

// // // // a test code or debug code to indicate UART receives successfully,
// // // // you can redirect received byte as echo also
// //  uart_write_bytes(
// //   //  EX_UART_NUM, 
// //    UART_NUM_0,
// //    (const char*) "RX Done", 7);

// // }

// /*
//  * Define UART interrupt subroutine to ackowledge interrupt
//  */
// static void IRAM_ATTR uart_intr_handle_u0(void *arg)
// {
//   uint16_t rx_fifo_len, status;
//   uint16_t i;
  
//   gpio_pad_select_gpio(BLINK_GPIO);
    
//   /* Set the GPIO as a push/pull output */
//   gpio_set_direction(BLINK_GPIO, GPIO_MODE_OUTPUT);


//   status = UART0.int_st.val; // read UART interrupt Status
//   rx_fifo_len = UART0.status.rxfifo_cnt; // read number of bytes in UART buffer
//   char single_byte = '-';
  
//   while(rx_fifo_len){
//     single_byte = UART0.fifo.rw_byte;
//     rxbuf[i++] = single_byte; // read all bytes
//     rx_fifo_len--;
//     gpio_set_level(BLINK_GPIO, rx_fifo_len%2);
//   }
    
//         // /* Blink off (output low) */
//         // gpio_set_level(BLINK_GPIO, !gpio_get_level(BLINK_GPIO));
//         /* Blink on (output high) */
//         // gpio_set_level(BLINK_GPIO, 1);
  
// //  // after reading bytes from buffer clear UART interrupt status
//  uart_clear_intr_status(UART_NUM_0, UART_RXFIFO_FULL_INT_CLR|UART_RXFIFO_TOUT_INT_CLR);

// // // a test code or debug code to indicate UART receives successfully,
// // // you can redirect received byte as echo also
// //  uart_write_bytes(
// //   //  EX_UART_NUM, 
// //    UART_NUM_2,
// //    (const char*) "RX Done", 7);

// // uart_tx_chars(UART_NUM_2,  (const char*)single_byte, 1);


//    uart_write_bytes(
//    UART_NUM_0,
//    (const char*) "Setup 0isr, port uart0 workin\n\r", 32);
//    uart_write_bytes(
//    UART_NUM_2,
//    (const char*) "Setup 0isr, port uart2 workin\n\r", 32);
// //  uart_write_bytes(
// //    UART_NUM_0,
// //    (const char*) single_byte, 1);

// }

// /*
//  * Define UART interrupt subroutine to ackowledge interrupt
//  */
// static void IRAM_ATTR uart_intr_handle_u1(void *arg)
// {
//   uint16_t rx_fifo_len, status;
//   uint16_t i;
  
//     gpio_pad_select_gpio(BLINK_GPIO);
    
//     /* Set the GPIO as a push/pull output */
//     gpio_set_direction(BLINK_GPIO, GPIO_MODE_OUTPUT);


//   status = UART1.int_st.val; // read UART interrupt Status
//   rx_fifo_len = UART1.status.rxfifo_cnt; // read number of bytes in UART buffer
//   char single_byte = '-';
  
//   while(rx_fifo_len){
//     single_byte = UART1.fifo.rw_byte;
//     rxbuf[i++] = single_byte; // read all bytes
//     rx_fifo_len--;
//     gpio_set_level(BLINK_GPIO, rx_fifo_len%2);
//   }
    
//         // /* Blink off (output low) */
//         // gpio_set_level(BLINK_GPIO, !gpio_get_level(BLINK_GPIO));
//         /* Blink on (output high) */
//         // gpio_set_level(BLINK_GPIO, 1);
  
// //  // after reading bytes from buffer clear UART interrupt status
//  uart_clear_intr_status(UART_NUM_1, UART_RXFIFO_FULL_INT_CLR|UART_RXFIFO_TOUT_INT_CLR);

// // // a test code or debug code to indicate UART receives successfully,
// // // you can redirect received byte as echo also
// //  uart_write_bytes(
// //   //  EX_UART_NUM, 
// //    UART_NUM_2,
// //    (const char*) "RX Done", 7);

// // uart_tx_chars(UART_NUM_2,  (const char*)single_byte, 1);


//    uart_write_bytes(
//    UART_NUM_0,
//    (const char*) "Setup 1isr, port uart0 workin\n\r", 32);
//    uart_write_bytes(
//    UART_NUM_2,
//    (const char*) "Setup 1isr, port uart2 workin\n\r", 32);
// //  uart_write_bytes(
// //    UART_NUM_0,
// //    (const char*) single_byte, 1);

// }

// /*
//  * Define UART interrupt subroutine to ackowledge interrupt
//  */
// static void IRAM_ATTR uart_intr_handle_u2(void *arg)
// {
//   uint16_t rx_fifo_len, status;
//   uint16_t i = 0;
  
//   // uart_write_bytes(
//   //  UART_NUM_1,
//   //  (const char*) "UART2 - uart_intr_handle_u2\n\r", 30);



//     gpio_pad_select_gpio(BLINK_GPIO);
    
//     /* Set the GPIO as a push/pull output */
//     gpio_set_direction(BLINK_GPIO, GPIO_MODE_OUTPUT);


//   status = UART2.int_st.val; // read UART interrupt Status
//   rx_fifo_len = UART2.status.rxfifo_cnt; // read number of bytes in UART buffer
//   char single_byte = '-';
  
//   while(rx_fifo_len){
//     single_byte = UART2.fifo.rw_byte;
//     rxbuf[i++] = single_byte; // read all bytes
//     rx_fifo_len--;
//     gpio_set_level(BLINK_GPIO, rx_fifo_len%2);
//     // uart_tx_chars(UART_NUM_1,  (const char*)single_byte, 1);
//     // uart_tx_chars(UART_NUM_2,  (const char*)single_byte, 1);
//   }
// urxlen = i;
//   // for(int ii=0;ii<i;ii++)
//     // if(i<30){
//       // uart_write_bytes(   UART_NUM_1,   (const char*) rxbuf, i-1);
//     // } 

    
//     // char message[100] = {0};
//     // for(int i=0;i<9;i++){
//     //   sprintf(message+strlen(message),"U2_%d",number);
//     // }
//     // number++;

// // BaseType_t dummyval;

// //     UBaseType_t res =  xRingbufferSendFromISR(settings.uart2.ringbuffer_handle, rxbuf, urxlen, &dummyval);
    
// //     if (res != pdTRUE) {
// //       Serial.printf("Failed to send item\n\r");
// //     }else{
// //       // Serial.printf("messaged added\n\r");
// //     }



//         // /* Blink off (output low) */
//         // gpio_set_level(BLINK_GPIO, !gpio_get_level(BLINK_GPIO));
//         /* Blink on (output high) */
//         // gpio_set_level(BLINK_GPIO, 1);
  
// //  // after reading bytes from buffer clear UART interrupt status
//  uart_clear_intr_status(UART_NUM_2, UART_RXFIFO_FULL_INT_CLR|UART_RXFIFO_TOUT_INT_CLR);

// // // a test code or debug code to indicate UART receives successfully,
// // // you can redirect received byte as echo also
// //  uart_write_bytes(
// //   //  EX_UART_NUM, 
// //    UART_NUM_2,
// //    (const char*) "RX Done", 7);

// // uart_tx_chars(UART_NUM_2,  (const char*)single_byte, 1);


//   //  uart_write_bytes(
//   //  UART_NUM_0,
//   //  (const char*) "Setup 2isr, port uart0 workin\n\r", 32);
//   //  uart_write_bytes(
//   //  UART_NUM_2,
//   //  (const char*) "Setup 2isr, port uart2 workin\n\r", 32);

// //  uart_write_bytes(
// //    UART_NUM_0,
// //    (const char*) single_byte, 1);

//   // uart_write_bytes(
//   //  UART_NUM_1,
//   //  (const char*) "UART2 - isr END\n\r", 18);
// }


// /*
//  * Define UART interrupt subroutine to ackowledge interrupt
//  */
// static void IRAM_ATTR uart_intr_handle_u2_q(void *arg)
// {
//   uint16_t rx_fifo_len, status;
//   uint16_t i = 0;
  
//   uart_write_bytes(
//    UART_NUM_1,
//    (const char*) "UART2 - uart_intr_handle_u2_q\n\r", 32);

// // Read data from UART.
// // const int uart_num = UART_NUM_2;
// // uint8_t data[128];
// // int length = 0;
// // ESP_ERROR_CHECK(uart_get_buffered_data_len(uart_num, (size_t*)&length));
// // length = uart_read_bytes(uart_num, data, length, 100);

// //If the data in the Rx FIFO buffer is no longer needed, you can clear the buffer by calling uart_flush().


//     // gpio_pad_select_gpio(BLINK_GPIO);
    
//     // /* Set the GPIO as a push/pull output */
//     // gpio_set_direction(BLINK_GPIO, GPIO_MODE_OUTPUT);


// //   status = UART2.int_st.val; // read UART interrupt Status
// //   rx_fifo_len = UART2.status.rxfifo_cnt; // read number of bytes in UART buffer
// //   char single_byte = '-';
  
// //   while(rx_fifo_len){
// //     single_byte = UART2.fifo.rw_byte;
// //     rxbuf[i++] = single_byte; // read all bytes
// //     rx_fifo_len--;
// //     gpio_set_level(BLINK_GPIO, rx_fifo_len%2);
// //     // uart_tx_chars(UART_NUM_1,  (const char*)single_byte, 1);
// //     // uart_tx_chars(UART_NUM_2,  (const char*)single_byte, 1);
// //   }
// // urxlen = i;
//   // for(int ii=0;ii<i;ii++)
//     // if(i<30){
//       // uart_write_bytes(   UART_NUM_1,   (const char*) rxbuf, i-1);
//     // } 
//         // /* Blink off (output low) */
//         // gpio_set_level(BLINK_GPIO, !gpio_get_level(BLINK_GPIO));
//         /* Blink on (output high) */
//         // gpio_set_level(BLINK_GPIO, 1);
  
// //  // after reading bytes from buffer clear UART interrupt status
//  uart_clear_intr_status(UART_NUM_2, UART_RXFIFO_FULL_INT_CLR|UART_RXFIFO_TOUT_INT_CLR);

// // // a test code or debug code to indicate UART receives successfully,
// // // you can redirect received byte as echo also
// //  uart_write_bytes(
// //   //  EX_UART_NUM, 
// //    UART_NUM_2,
// //    (const char*) "RX Done", 7);

// // uart_tx_chars(UART_NUM_2,  (const char*)single_byte, 1);


//   //  uart_write_bytes(
//   //  UART_NUM_0,
//   //  (const char*) "Setup 2isr, port uart0 workin\n\r", 32);
//   //  uart_write_bytes(
//   //  UART_NUM_2,
//   //  (const char*) "Setup 2isr, port uart2 workin\n\r", 32);

// //  uart_write_bytes(
// //    UART_NUM_0,
// //    (const char*) single_byte, 1);

//   uart_write_bytes(
//    UART_NUM_1,
//    (const char*) "UART2 - isr ENDq\n\r", 19);
// }



// void UART_Setup();
// void UART_Loop();
// #endif // USE_DEVFEATURE_UART_TEST


/*

#ifdef USE_DEVFEATURE_UART_TEST

const uart_port_t uart_num = UART_NUM_2;

// UART Handler
// static void IRAM_ATTR uart_intr_handle(void *arg) {
//   // uint16_t rx_fifo_len;
  
//   // //status = UART0.int_st.val;            // Read UART interrupt Status
//   // rx_fifo_len = UART0.status.rxfifo_cnt;  // Read number of bytes in UART buffer
  
//   // while(rx_fifo_len){
//   //  rxbuf[nrBytes++] = READ_PERI_REG(UART_FIFO_AHB_REG(0));//UART0.fifo.rw_byte;       // Read all bytes
//   //  rx_fifo_len--;
//   // }

//   // UART_RECEIVED = 1;                      // Set flag

//   // // After reading bytes from buffer clear UART interrupt status
//   // uart_clear_intr_status(uart_num , UART_RXFIFO_FULL_INT_CLR|UART_RXFIFO_TOUT_INT_CLR);
// }

static void IRAM_ATTR uart_intr_handle4(void* arg)
{
  //uart_write_bytes(UART_NUM_0, (const char*) "uart_intr_handle4\n\r", 20);
}


void UART_Setup(){

gpio_pad_select_gpio(BLINK_GPIO);
    
    * Set the GPIO as a push/pull output *
    gpio_set_direction(BLINK_GPIO, GPIO_MODE_OUTPUT);

    init_UART0();
    init_UART1();
    // pCONT_uart- init_UART2();


//  uart_config_t uart_config = {
// 	      .baud_rate = 115200,
// 	      .data_bits = UART_DATA_8_BITS,
// 	      .parity = UART_PARITY_ODD,
// 	      .stop_bits = UART_STOP_BITS_1,
// 	      .flow_ctrl = UART_HW_FLOWCTRL_DISABLE
// 	    };
// 	    ESP_ERROR_CHECK(uart_param_config(uart_num , &uart_config));
// 	    ESP_ERROR_CHECK(uart_set_pin(uart_num , UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));   // Set UART pins (using UART0 default pins ie no changes.)
// 	    ESP_ERROR_CHECK(uart_driver_install(uart_num , BUF_SIZE * 2, BUF_SIZE * 2, 10, NULL, 0));                    // Install UART driver, and get the queue.        
// 	    // ESP_ERROR_CHECK(uart_driver_install(uart_num , 0, 0, 0, NULL, 0));                    // Install UART driver, and get the queue.        
// 	    ESP_ERROR_CHECK(uart_isr_free(uart_num ));                                                                  // Release the pre registered UART handler/subroutine
// 	    ESP_ERROR_CHECK(uart_isr_register(uart_num ,uart_intr_handle, NULL, ESP_INTR_FLAG_IRAM, NULL));             // Register new UART subroutine
// 	    ESP_ERROR_CHECK(uart_enable_rx_intr(uart_num ));


// int ret;
// 	esp_log_level_set(TAG, ESP_LOG_INFO);

// 	* Configure parameters of an UART driver,
// 	* communication pins and install the driver *
// 	uart_config_t uart_config = {
// 		.baud_rate = 115200,
// 		.data_bits = UART_DATA_8_BITS,
// 		.parity = UART_PARITY_DISABLE,
// 		.stop_bits = UART_STOP_BITS_1,
// 		.flow_ctrl = UART_HW_FLOWCTRL_DISABLE
// 	};

//   Serial1.begin(115200);




	// ESP_ERROR_CHECK(uart_param_config(UART_NUM_2, &uart_config));

	// //Set UART log level
	// esp_log_level_set(TAG, ESP_LOG_INFO);

	// //Set UART pins (using UART0 default pins ie no changes.)
	// ESP_ERROR_CHECK(uart_set_pin(UART_NUM_2, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));

	// //Install UART driver, and get the queue.
	// ESP_ERROR_CHECK(
  //   uart_driver_install(UART_NUM_2, BUF_SIZE * 2, 0, 0, NULL, 0)
  //    );

  //  uart_write_bytes(
  //  UART_NUM_2,
  //  (const char*) "Setup done, port uart2 working", 31);

	// release the pre registered UART handler/subroutine
	// ESP_ERROR_CHECK(uart_isr_free(EX_UART_NUM));

	// // register new UART subroutine
	// ESP_ERROR_CHECK(uart_isr_register(EX_UART_NUM,uart_intr_handle, NULL, ESP_INTR_FLAG_IRAM, &handle_console));

	// // enable RX interrupt
	// ESP_ERROR_CHECK(uart_enable_rx_intr(EX_UART_NUM));

// 	#if (NOTASK == 1)
// 	while(1)
// 	{
// 		vTaskDelay(1000);
// 	}
// 	#else
		// xTaskCreate(&blink_task, "blink_task", configMINIMAL_STACK_SIZE, NULL, 5, NULL);
	// #endif
}

void init_UART0(){

	esp_log_level_set(TAG, ESP_LOG_INFO);

	* Configure parameters of an UART driver,
	* communication pins and install the driver *
	uart_config_t uart_config = {
		.baud_rate = 115200,
		.data_bits = UART_DATA_8_BITS,
		.parity = UART_PARITY_DISABLE,
		.stop_bits = UART_STOP_BITS_1,
		.flow_ctrl = UART_HW_FLOWCTRL_DISABLE
	};

  //PORT 0 for debug
  ESP_ERROR_CHECK(uart_param_config(UART_NUM_0, &uart_config));

	//Set UART log level
	esp_log_level_set(TAG, ESP_LOG_INFO);

	//Set UART pins (using UART0 default pins ie no changes.)
	ESP_ERROR_CHECK(uart_set_pin(UART_NUM_0, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));

	//Install UART driver, and get the queue.
	ESP_ERROR_CHECK(uart_driver_install(UART_NUM_0, BUF_SIZE * 2, 0, 0, NULL, 0));

	// release the pre registered UART handler/subroutine
	ESP_ERROR_CHECK(uart_isr_free(UART_NUM_0));

	// register new UART subroutine
	ESP_ERROR_CHECK(uart_isr_register(UART_NUM_0,uart_intr_handle_u0, NULL, ESP_INTR_FLAG_IRAM, &handle_console_u0));

	// enable RX interrupt
	ESP_ERROR_CHECK(uart_enable_rx_intr(UART_NUM_0));

  uart_write_bytes(
   UART_NUM_0,
   (const char*) "UART0 - Reboot\n\r", 17);
  
}

void init_UART1(){

	// esp_log_level_set(TAG, ESP_LOG_INFO);

	* Configure parameters of an UART driver,
	* communication pins and install the driver *
	uart_config_t uart_config = {
		.baud_rate = 115200,
		.data_bits = UART_DATA_8_BITS,
		.parity = UART_PARITY_DISABLE,
		.stop_bits = UART_STOP_BITS_1,
		.flow_ctrl = UART_HW_FLOWCTRL_DISABLE
	};

  // Serial1.begin(115200);
  // Serial1.println("115200this");

  //PORT 0 for debug
  ESP_ERROR_CHECK(uart_param_config(UART_NUM_1, &uart_config));

	//Set UART log level
	// esp_log_level_set(TAG, ESP_LOG_INFO);

	//Set UART pins (using UART0 default pins ie no changes.)
	ESP_ERROR_CHECK(uart_set_pin(UART_NUM_1, 25, 26, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));

	//Install UART driver, and get the queue.
	ESP_ERROR_CHECK(uart_driver_install(UART_NUM_1, BUF_SIZE * 2, 0, 0, NULL, 0));

	// release the pre registered UART handler/subroutine
	ESP_ERROR_CHECK(uart_isr_free(UART_NUM_1));

	// register new UART subroutine
	ESP_ERROR_CHECK(uart_isr_register(UART_NUM_1,uart_intr_handle_u1, NULL, ESP_INTR_FLAG_IRAM, &handle_console_u0));

	// enable RX interrupt
	ESP_ERROR_CHECK(uart_enable_rx_intr(UART_NUM_1));

  uart_write_bytes(
   UART_NUM_1,
   (const char*) "UART1 - Reboot\n\r", 17);

  
}

// #define UART2_METHOD_NO_QUEUE
// #define UART2_METHOD_QUEUE

void init_UART2(){

#ifdef UART2_METHOD_NO_QUEUE
	// esp_log_level_set(TAG, ESP_LOG_INFO);

	* Configure parameters of an UART driver,
	* communication pins and install the driver *
	uart_config_t uart_config = {
		.baud_rate = 115200,
		.data_bits = UART_DATA_8_BITS,
		.parity = UART_PARITY_DISABLE,
		.stop_bits = UART_STOP_BITS_1,
		.flow_ctrl = UART_HW_FLOWCTRL_DISABLE
	};

  // Serial1.begin(115200);
  // Serial1.println("115200this");

  //PORT 0 for debug
  ESP_ERROR_CHECK(uart_param_config(UART_NUM_2, &uart_config));

	//Set UART log level
	// esp_log_level_set(TAG, ESP_LOG_INFO);

	//Set UART pins (using UART0 default pins ie no changes.)
	ESP_ERROR_CHECK(uart_set_pin(UART_NUM_2, 17, 16, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));

	//Install UART driver, and get the queue.
	ESP_ERROR_CHECK(uart_driver_install(UART_NUM_2, BUF_SIZE * 2, 0, 0, NULL, 0));

	// release the pre registered UART handler/subroutine
	ESP_ERROR_CHECK(uart_isr_free(UART_NUM_2));

	// register new UART subroutine
	ESP_ERROR_CHECK(uart_isr_register(UART_NUM_2,uart_intr_handle_u2, NULL, ESP_INTR_FLAG_IRAM, &handle_console_u0));

	// enable RX interrupt
	ESP_ERROR_CHECK(uart_enable_rx_intr(UART_NUM_2));
#endif // UART2_METHOD_NO_QUEUE
  
#ifdef UART2_METHOD_QUEUE

 int ret;
    esp_log_level_set(TAG, ESP_LOG_INFO);

    * Configure parameters of an UART driver,
     * communication pins and install the driver *
    uart_config_t uart_config = {
        .baud_rate = 115200,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE
    };

    ESP_ERROR_CHECK(uart_param_config(UART_NUM_2, &uart_config));


// // Setup UART buffered IO with event queue
// const int uart_buffer_size = (1024 * 2);
// QueueHandle_t uart2_event_queue_handle;

    //Set UART log level
    // esp_log_level_set(TAG, ESP_LOG_INFO);
    // ESP_LOGI(TAG, "uart event main");
    //Set UART pins (using UART0 default pins ie no changes.)
    // ESP_ERROR_CHECK(uart_set_pin(EX_UART_NUM, GPIO_NUM_4, GPIO_NUM_5, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));
	// ESP_ERROR_CHECK(uart_set_pin(UART_NUM_2, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));
	ESP_ERROR_CHECK(uart_set_pin(UART_NUM_2, 17, 16, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));
    //Install UART driver, and get the queue.
    ESP_ERROR_CHECK(uart_driver_install(UART_NUM_2, uart_buffer_size, uart_buffer_size, 10, &uart2_event_queue_handle, 0));

	// // release the pre registered UART handler/subroutine
	ESP_ERROR_CHECK(uart_isr_free(UART_NUM_2));
  //   // ESP_LOGI(TAG, "uart init interrupt");
  //   // ESP_ERROR_CHECK(uart_enable_intr_mask(EX_UART_NUM, UART_INTR_MASK));
  // //    //Set uart pattern detect function.
  // //    uart_enable_pattern_det_intr(EX_UART_NUM, '+', PATTERN_CHR_NUM, 10000, 10, 10);
  // //    //Reset the pattern queue length to record at most 20 pattern positions.
  // //    uart_pattern_queue_reset(EX_UART_NUM, 20);
  //   // ESP_LOGI(TAG, "uart reg isr interrupt");
    ESP_ERROR_CHECK(uart_isr_register(UART_NUM_2,
    uart_intr_handle_u2,
    // uart_intr_handle4,
    
     NULL, 
    
    ESP_INTR_FLAG_IRAM,// | ESP_INTR_FLAG_LOWMED,
    // ESP_INTR_FLAG_IRAM | ESP_INTR_FLAG_LOWMED,
    // ESP_INTR_FLAG_LOWMED, 
    
    handle_console4));

  //   // ESP_LOGI(TAG, "uart rx isr enable");
  //   //ESP_LOGI(TAG, "Return from UART ISR %X", ret);
    // ESP_ERROR_CHECK(uart_enable_rx_intr(UART_NUM_2));
    //Create a task to handler UART event from ISR

    //xTaskCreatePinnedToCore
    // xTaskCreatePinnedToCore()
    
    // 	uart2_event_queue_handle = xQueueCreate( 10, sizeof( struct AMessage * ) );
 	  // if( uart2_event_queue_handle == 0 )
  	// {
    //   // Serial.println("uart2_event_queue_handle FAILED!"); delay(4000);
  	// 	// Failed to create the queue.
  	// }
    //   // Serial.println("uart2_event_queue_handle SUCESS!"); delay(4000);

    // 	uart0_queue = xQueueCreate( 10, sizeof( struct AMessage * ) );
 	  // if( uart0_queue == 0 )
  	// {
    //   // Serial.println("uart2_event_queue_handle FAILED!"); delay(4000);
  	// 	// Failed to create the queue.
  	// }
      // Serial.println("uar/t_queue SUCESS!"); delay(4000);

    
    // xTaskCreate(uart_event_task, "uart_event_task", 2048, NULL, 12, NULL);
#endif // UART2_METHOD_QUEUE




  // uart_write_bytes(
  //  UART_NUM_2,
  //  (const char*) "UART2 - Reboot\n\r", 17);

  
}


void UART_Loop(){

  // Serial.println("loop");

  // if(urxlen){
  //   for(int ii=0;ii<urxlen;ii++){
  //     Serial.print((char)rxbuf[ii]);
  //   }
  //   Serial.println();
  //   urxlen = 0;
  // }


}


#endif // UART_TEST

*/


  // yield();
// #ifdef USE_DEVFEATURE_UART_TEST
//   // UART_Loop();

//   // https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/freertos_additions.html

// /**
//  * @brief   Get information about ring buffer status
//  *
//  * Get information of the a ring buffer's current status such as
//  * free/read/write pointer positions, and number of items waiting to be retrieved.
//  * Arguments can be set to NULL if they are not required.
//  *
//  * @param[in]   xRingbuffer     Ring buffer to remove from the queue set
//  * @param[out]  uxFree          Pointer use to store free pointer position
//  * @param[out]  uxRead          Pointer use to store read pointer position
//  * @param[out]  uxWrite         Pointer use to store write pointer position
//  * @param[out]  uxItemsWaiting  Pointer use to store number of items (bytes for byte buffer) waiting to be retrieved
//  */
// // void vRingbufferGetInfo(RingbufHandle_t xRingbuffer, UBaseType_t *uxFree, UBaseType_t *uxRead, UBaseType_t *uxWrite, UBaseType_t *uxItemsWaiting);
// // RingbufHandle_t xRingbuffer;
// // UBaseType_t *uxFree;
// // UBaseType_t *uxRead;
// // UBaseType_t *uxWrite;
// // UBaseType_t *uxItemsWaiting;
// // vRingbufferGetInfo(xRingbuffer, uxFree, uxRead, uxWrite, uxItemsWaiting);

// #ifdef ENABLE_DEVFEATURE_BYTEBUFFER
//   if(abs(millis() - tick_fill)>1000){ tick_fill = millis();
//     Serial.println("Writing into buffer");

//     char message[100] = {0};
//     for(int i=0;i<9;i++){
//       sprintf(message+strlen(message),"%d",number);
//     }
//     number++;

//     UBaseType_t res =  xRingbufferSend(buf_handle, message, strlen(message), pdMS_TO_TICKS(1000));
//     if (res != pdTRUE) {
//       Serial.printf("Failed to send item\n\r");
//     }else{
//       // Serial.printf("messaged added\n\r");
//     }
    
//   //   // freeSize = xRingbufferGetCurFreeSize(buf_handle);
//   //   // Serial.printf("freeSize1=%d\n\r",freeSize);

//   //   // UBaseType_t res2 =  xRingbufferSend(buf_handle, message, sizeof(message), pdMS_TO_TICKS(1000));
//   //   // if (res2 != pdTRUE) {
//   //   //   Serial.printf("Failed to send item\n\r");
//   //   // }else{
//   //   //   // Serial.printf("messaged added\n\r");
//   //   // }

//   //   // freeSize = xRingbufferGetCurFreeSize(buf_handle);
//   //   // Serial.printf("freeSize2=%d\n\r",freeSize);


//   //   //  for(int i=0;i<10;i++){
//   //   //   sprintf(message+strlen(message),"a",number);
//   //   // }
//   //   // res =  xRingbufferSend(buf_handle, message, 
//   //   // //sizeof(tx_item), 
//   //   // sizeof(message),
//   //   // pdMS_TO_TICKS(1000));
//   //   // if (res != pdTRUE) {
//   //   //   Serial.printf("Failed to send item\n\r");
//   //   // }else{
//   //   //   // Serial.printf("messaged added\n\r");
//   //   // }
    
//   //   // Serial.printf("buff>>%s",bu);

//   }


// #endif // test

//   if(abs(millis() - tick_read)>=10000){ tick_read = millis();
//     //Receive an item from allow-split ring buffer

//     // xRingbufferPrintInfo(buf_handle);
//     // //Receive an item from no-split ring buffer
//     // size_t item_size;
//     // char *item = (char *)xRingbufferReceive(buf_handle, &item_size, pdMS_TO_TICKS(1000));

//     // //Check received item
//     // if (item != NULL) {
//     //     //Print item
//     //     for (int i = 0; i < item_size; i++) {
//     //         printf("%c", item[i]);
//     //     }
//     //     printf("\n");
//     //     //Return Item
//     //     vRingbufferReturnItem(buf_handle, (void *)item);
//     // } else {
//     //     //Failed to receive item
//     //     printf("Failed to receive item\n");
//     // }


//     // while(
//     //   (freeSize = xRingbufferGetCurFreeSize(buf_handle))
//     //   <
//     //   984
//     //   ){
    
//     //   Serial.printf("freeSize while = %d\n\r",freeSize);

//     //   if(abs(millis() - tick_read)>10000){
//     //     break;
//     //   }
      
//     //   size_t item_size1, item_size2;
//     //   char *item1, *item2;
//     //   BaseType_t ret = xRingbufferReceiveSplit(buf_handle, (void **)&item1, (void **)&item2, &item_size1, &item_size2, pdMS_TO_TICKS(1000));

//     //   //Check received item
//     //   if (ret == pdTRUE && item1 != NULL) {
//     //     Serial.printf("item1 size = %d\n\r", item_size1);
//     //     for (int i = 0; i < item_size1; i++) {
//     //       Serial.printf("%c", item1[i]);
//     //     }
//     //     vRingbufferReturnItem(buf_handle, (void *)item1);
//     //     //Check if item was split
//     //     if (item2 != NULL) {
//     //       for (int i = 0; i < item_size2; i++) {
//     //         Serial.printf("%c", item2[i]);
//     //       }
//     //       vRingbufferReturnItem(buf_handle, (void *)item2);
//     //     }
//     //     Serial.printf("\n");
//     //   } else {
//     //     //Failed to receive item
//     //     Serial.printf("Failed to receive item\n");
//     //   }

//     // xRingbufferPrintInfo(uart2_settings.ringbuffer_handle);
//     // //Receive an item from no-split ring buffer
//     size_t item_size;
//     char*  item = (char *)xRingbufferReceive(pCONT_uart->uart2_settings.ringbuffer_handle, &item_size, pdMS_TO_TICKS(1000));

//     //Check received item
//     if (item != NULL) {
//       Serial.printf("UART2:>%d %d sizeB=%d\n\r",item_size,millis(),xRingbufferGetCurFreeSize(pCONT_uart->uart2_settings.ringbuffer_handle));
//       //Print item
//       for (int i = 0; i < item_size; i++) {
//           Serial.printf("%c", item[i]);
//       }
//       //Return Item
//       vRingbufferReturnItem(pCONT_uart->uart2_settings.ringbuffer_handle, (void *)item);
//       Serial.printf("\n\r sizeA=%d\n\r",xRingbufferGetCurFreeSize(pCONT_uart->uart2_settings.ringbuffer_handle));
//     } else {
//       //Failed to receive item
//       Serial.printf("Failed to receive item\n");
//     }




// // xRingbufferPrintInfo(buf_handle);
  
//     }
//     // read half out

//     //print whole buffer
//     // for(int ii=0;ii<100;ii++){
//     //   Serial.print((char)buffer_test[ii]);
//     // }
//     // Serial.println();

//   // }